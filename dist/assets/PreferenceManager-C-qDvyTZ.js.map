{"version":3,"mappings":"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","names":["PreferencePreloader","config","storage","PreferenceManager","startTime","duration","error","criticalResult","newConfig","IntelligentCache","strategy","key","_type","entry","now","data","type","customTTL","dataSize","preferences","result","cleared","totalEntries","totalSize","totalAccessTime","hitRate","missRate","averageAccessTime","newStrategy","entries","newEntrySize","currentSize","requiredSpace","a","b","freedSpace","entriesToEvict","PreferenceValidationAPI","request","response","level","errors","warnings","criticalFields","suggestions","validationRules","rule","value","logicValidation","baseRules","startMinutes","endMinutes","time","hours","minutes","PreferenceChangeDetector","oldPreferences","newPreferences","changes","requiresGapRecalculation","requiresImmediateUpdate","field","oldValue","newValue","changeEvent","affectedDateRange","summary","impact","change","today","start","endDateObj","end","_oldValue","_newValue","dates","date","tomorrow","oldList","newList","criticalChanges","c","mediumChanges","lowChanges","parts","i","keysA","keysB","cachedPrefs","resolve","DEFAULT_PREFERENCES","prefs","validation","validationError","normalizeDays","val","normalizedOld","normalizedNew","changeResult","cachedCritical","defaultCritical","criticalPrefs","acc","timeFields","preferencesAPI","__vitePreload","n","diff","oldPrefs","newPrefs","keys","k","ov","nv"],"ignoreList":[],"sources":["../../utils/storage/PreferencePreloader.ts","../../utils/storage/IntelligentCache.ts","../../utils/api/preferenceValidation.ts","../../utils/storage/PreferenceChangeDetector.ts","../../utils/storage/PreferenceManager.ts"],"sourcesContent":["import { PreferenceManager } from './PreferenceManager';\n\nexport interface PreloadConfig {\n  preloadCritical: boolean;\n  preloadFull: boolean;\n  preloadOnAppStart: boolean;\n  preloadOnAuth: boolean;\n  preloadOnFocus: boolean;\n  preloadTimeout: number;\n}\n\nexport interface PreloadResult {\n  success: boolean;\n  criticalLoaded: boolean;\n  fullLoaded: boolean;\n  duration: number;\n  error?: string;\n}\n\nexport class PreferencePreloader {\n  private static instance: PreferencePreloader;\n  private preferenceManager: PreferenceManager | null = null;\n  private config: PreloadConfig;\n  private isPreloading = false;\n  private preloadPromise: Promise<PreloadResult> | null = null;\n  private lastPreloadTime = 0;\n  private preloadTimeout: NodeJS.Timeout | null = null;\n\n  private constructor(config: Partial<PreloadConfig> = {}) {\n    this.config = {\n      preloadCritical: true,\n      preloadFull: false,\n      preloadOnAppStart: true,\n      preloadOnAuth: true,\n      preloadOnFocus: false,\n      preloadTimeout: 5000, // 5 seconds timeout\n      ...config\n    };\n  }\n\n  static getInstance(config?: Partial<PreloadConfig>): PreferencePreloader {\n    if (!PreferencePreloader.instance) {\n      PreferencePreloader.instance = new PreferencePreloader(config);\n    }\n    return PreferencePreloader.instance;\n  }\n\n  /**\n   * Initialize the preloader with storage\n   */\n  initialize(storage: any): void {\n    this.preferenceManager = PreferenceManager.getInstance(storage);\n  }\n\n  /**\n   * Preload critical preferences immediately\n   */\n  async preloadCritical(): Promise<PreloadResult> {\n    if (!this.preferenceManager) {\n      throw new Error('PreferencePreloader not initialized');\n    }\n\n    const startTime = performance.now();\n    \n    try {\n      console.log('🚀 Preloading critical preferences...');\n      \n      // Get critical preferences (this is fast and always available)\n      this.preferenceManager.getCriticalPreferences();\n      \n      const duration = performance.now() - startTime;\n      console.log(`✅ Critical preferences preloaded in ${duration.toFixed(2)}ms`);\n      \n      this.lastPreloadTime = Date.now();\n      \n      return {\n        success: true,\n        criticalLoaded: true,\n        fullLoaded: false,\n        duration\n      };\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      console.error('❌ Failed to preload critical preferences:', error);\n      \n      return {\n        success: false,\n        criticalLoaded: false,\n        fullLoaded: false,\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\n   * Preload full preferences in background\n   */\n  async preloadFull(): Promise<PreloadResult> {\n    if (!this.preferenceManager) {\n      throw new Error('PreferencePreloader not initialized');\n    }\n\n    const startTime = performance.now();\n    \n    try {\n      console.log('🔄 Preloading full preferences...');\n      \n      // Get full preferences (this may take longer)\n      await this.preferenceManager.getPreferences();\n      \n      const duration = performance.now() - startTime;\n      console.log(`✅ Full preferences preloaded in ${duration.toFixed(2)}ms`);\n      \n      this.lastPreloadTime = Date.now();\n      \n      return {\n        success: true,\n        criticalLoaded: true,\n        fullLoaded: true,\n        duration\n      };\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      console.error('❌ Failed to preload full preferences:', error);\n      \n      return {\n        success: false,\n        criticalLoaded: false,\n        fullLoaded: false,\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\n   * Smart preload based on configuration\n   */\n  async preload(): Promise<PreloadResult> {\n    if (this.isPreloading && this.preloadPromise) {\n      console.log('⏳ Preload already in progress, waiting...');\n      return this.preloadPromise;\n    }\n\n    this.isPreloading = true;\n    \n    // Set timeout for preload operation\n    this.preloadTimeout = setTimeout(() => {\n      console.warn('⚠️ Preference preload timeout reached');\n      this.isPreloading = false;\n    }, this.config.preloadTimeout);\n\n    try {\n      // Always preload critical first\n      const criticalResult = await this.preloadCritical();\n      \n      if (!criticalResult.success) {\n        return criticalResult;\n      }\n\n      // Preload full if configured\n      if (this.config.preloadFull) {\n        const fullResult = await this.preloadFull();\n        return fullResult;\n      }\n\n      return criticalResult;\n    } finally {\n      this.isPreloading = false;\n      if (this.preloadTimeout) {\n        clearTimeout(this.preloadTimeout);\n        this.preloadTimeout = null;\n      }\n    }\n  }\n\n  /**\n   * Preload on app start\n   */\n  async preloadOnAppStart(): Promise<PreloadResult> {\n    if (!this.config.preloadOnAppStart) {\n      console.log('⏭️ App start preload disabled');\n      return {\n        success: true,\n        criticalLoaded: false,\n        fullLoaded: false,\n        duration: 0\n      };\n    }\n\n    console.log('🚀 Preloading preferences on app start...');\n    return this.preload();\n  }\n\n  /**\n   * Preload on authentication\n   */\n  async preloadOnAuth(): Promise<PreloadResult> {\n    if (!this.config.preloadOnAuth) {\n      console.log('⏭️ Auth preload disabled');\n      return {\n        success: true,\n        criticalLoaded: false,\n        fullLoaded: false,\n        duration: 0\n      };\n    }\n\n    console.log('🔐 Preloading preferences on authentication...');\n    return this.preload();\n  }\n\n  /**\n   * Preload on app focus (background refresh)\n   */\n  async preloadOnFocus(): Promise<PreloadResult> {\n    if (!this.config.preloadOnFocus) {\n      console.log('⏭️ Focus preload disabled');\n      return {\n        success: true,\n        criticalLoaded: false,\n        fullLoaded: false,\n        duration: 0\n      };\n    }\n\n    // Only preload if enough time has passed since last preload\n    const timeSinceLastPreload = Date.now() - this.lastPreloadTime;\n    if (timeSinceLastPreload < 5 * 60 * 1000) { // 5 minutes\n      console.log('⏭️ Skipping focus preload (too recent)');\n      return {\n        success: true,\n        criticalLoaded: true,\n        fullLoaded: true,\n        duration: 0\n      };\n    }\n\n    console.log('📱 Preloading preferences on app focus...');\n    return this.preload();\n  }\n\n  /**\n   * Get preload status\n   */\n  getStatus(): {\n    isPreloading: boolean;\n    lastPreloadTime: number;\n    timeSinceLastPreload: number;\n    config: PreloadConfig;\n  } {\n    return {\n      isPreloading: this.isPreloading,\n      lastPreloadTime: this.lastPreloadTime,\n      timeSinceLastPreload: Date.now() - this.lastPreloadTime,\n      config: this.config\n    };\n  }\n\n  /**\n   * Update preload configuration\n   */\n  updateConfig(newConfig: Partial<PreloadConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    console.log('⚙️ Updated preload configuration:', this.config);\n  }\n\n  /**\n   * Reset preloader state\n   */\n  reset(): void {\n    this.isPreloading = false;\n    this.preloadPromise = null;\n    this.lastPreloadTime = 0;\n    if (this.preloadTimeout) {\n      clearTimeout(this.preloadTimeout);\n      this.preloadTimeout = null;\n    }\n    console.log('🔄 Preference preloader reset');\n  }\n} ","import { UserPreferences } from '../../types/index';\n\nexport interface CacheStrategy {\n  critical: {\n    ttl: number;\n    priority: 'high' | 'medium' | 'low';\n    preload: boolean;\n    maxSize: number;\n  };\n  nonCritical: {\n    ttl: number;\n    priority: 'high' | 'medium' | 'low';\n    preload: boolean;\n    maxSize: number;\n  };\n  validation: {\n    ttl: number;\n    priority: 'high' | 'medium' | 'low';\n    preload: boolean;\n    maxSize: number;\n  };\n}\n\nexport interface CacheEntry<T = any> {\n  data: T;\n  timestamp: number;\n  ttl: number;\n  priority: 'high' | 'medium' | 'low';\n  accessCount: number;\n  lastAccess: number;\n  size: number;\n}\n\nexport interface CacheStats {\n  totalEntries: number;\n  totalSize: number;\n  hitRate: number;\n  missRate: number;\n  evictions: number;\n  averageAccessTime: number;\n  memoryUsage: number;\n}\n\nexport class IntelligentCache {\n  private cache = new Map<string, CacheEntry>();\n  private strategy: CacheStrategy;\n  private stats = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    totalAccesses: 0\n  };\n\n  constructor(strategy?: Partial<CacheStrategy>) {\n    this.strategy = {\n      critical: {\n        ttl: 24 * 60 * 60 * 1000, // 24 hours\n        priority: 'high',\n        preload: true,\n        maxSize: 1024 * 1024 // 1MB\n      },\n      nonCritical: {\n        ttl: 60 * 60 * 1000, // 1 hour\n        priority: 'medium',\n        preload: false,\n        maxSize: 512 * 1024 // 512KB\n      },\n      validation: {\n        ttl: 30 * 60 * 1000, // 30 minutes\n        priority: 'low',\n        preload: false,\n        maxSize: 256 * 1024 // 256KB\n      },\n      ...strategy\n    };\n  }\n\n  /**\n   * Get data from cache with intelligent TTL\n   */\n  get<T>(key: string, _type: keyof CacheStrategy = 'nonCritical'): T | null {\n    this.stats.totalAccesses++;\n    const startTime = performance.now();\n\n    const entry = this.cache.get(key);\n    if (!entry) {\n      this.stats.misses++;\n      return null;\n    }\n\n    // Check if entry is expired\n    const now = Date.now();\n    if (now - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      this.stats.misses++;\n      return null;\n    }\n\n    // Update access statistics\n    entry.accessCount++;\n    entry.lastAccess = now;\n\n    this.stats.hits++;\n    // const accessTime = performance.now() - startTime;\n\n    return entry.data as T;\n  }\n\n  /**\n   * Set data in cache with intelligent strategy\n   */\n  set<T>(\n    key: string, \n    data: T, \n    type: keyof CacheStrategy = 'nonCritical',\n    customTTL?: number\n  ): void {\n    const strategy = this.strategy[type];\n    const dataSize = this.calculateSize(data);\n\n    // Check if we need to evict entries\n    this.ensureCapacity(type, dataSize);\n\n    const entry: CacheEntry<T> = {\n      data,\n      timestamp: Date.now(),\n      ttl: customTTL || strategy.ttl,\n      priority: strategy.priority,\n      accessCount: 0,\n      lastAccess: Date.now(),\n      size: dataSize\n    };\n\n    this.cache.set(key, entry);\n  }\n\n  /**\n   * Get critical preferences with high priority caching\n   */\n  getCriticalPreferences(): Partial<UserPreferences> | null {\n    return this.get<Partial<UserPreferences>>('critical_preferences', 'critical');\n  }\n\n  /**\n   * Set critical preferences with high priority caching\n   */\n  setCriticalPreferences(preferences: Partial<UserPreferences>): void {\n    this.set('critical_preferences', preferences, 'critical');\n  }\n\n  /**\n   * Get full preferences with medium priority caching\n   */\n  getFullPreferences(): UserPreferences | null {\n    return this.get<UserPreferences>('full_preferences', 'nonCritical');\n  }\n\n  /**\n   * Set full preferences with medium priority caching\n   */\n  setFullPreferences(preferences: UserPreferences): void {\n    this.set('full_preferences', preferences, 'nonCritical');\n  }\n\n  /**\n   * Get validation result with low priority caching\n   */\n  getValidationResult(key: string): any {\n    return this.get(`validation_${key}`, 'validation');\n  }\n\n  /**\n   * Set validation result with low priority caching\n   */\n  setValidationResult(key: string, result: any): void {\n    this.set(`validation_${key}`, result, 'validation');\n  }\n\n  /**\n   * Check if cache has valid entry\n   */\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) return false;\n\n    const now = Date.now();\n    return now - entry.timestamp <= entry.ttl;\n  }\n\n  /**\n   * Delete entry from cache\n   */\n  delete(key: string): boolean {\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clear(): void {\n    this.cache.clear();\n    this.resetStats();\n  }\n\n  /**\n   * Clear expired entries\n   */\n  clearExpired(): number {\n    const now = Date.now();\n    let cleared = 0;\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > entry.ttl) {\n        this.cache.delete(key);\n        cleared++;\n      }\n    }\n\n    return cleared;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    const totalEntries = this.cache.size;\n    let totalSize = 0;\n    let totalAccessTime = 0;\n\n    for (const entry of this.cache.values()) {\n      totalSize += entry.size;\n      totalAccessTime += entry.accessCount;\n    }\n\n    const hitRate = this.stats.totalAccesses > 0 ? this.stats.hits / this.stats.totalAccesses : 0;\n    const missRate = this.stats.totalAccesses > 0 ? this.stats.misses / this.stats.totalAccesses : 0;\n    const averageAccessTime = totalEntries > 0 ? totalAccessTime / totalEntries : 0;\n\n    return {\n      totalEntries,\n      totalSize,\n      hitRate,\n      missRate,\n      evictions: this.stats.evictions,\n      averageAccessTime,\n      memoryUsage: this.getMemoryUsage()\n    };\n  }\n\n  /**\n   * Update cache strategy\n   */\n  updateStrategy(newStrategy: Partial<CacheStrategy>): void {\n    this.strategy = { ...this.strategy, ...newStrategy };\n  }\n\n  /**\n   * Get cache entries by type\n   */\n  getEntriesByType(type: keyof CacheStrategy): Array<{ key: string; entry: CacheEntry }> {\n    const entries: Array<{ key: string; entry: CacheEntry }> = [];\n    \n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.priority === this.strategy[type].priority) {\n        entries.push({ key, entry });\n      }\n    }\n\n    return entries;\n  }\n\n  /**\n   * Ensure cache capacity for new entry\n   */\n  private ensureCapacity(type: keyof CacheStrategy, newEntrySize: number): void {\n    const _strategy = this.strategy[type];\n    const entries = this.getEntriesByType(type);\n    \n    let currentSize = 0;\n    for (const { entry } of entries) {\n      currentSize += entry.size;\n    }\n\n    // If adding this entry would exceed max size, evict some entries\n    if (currentSize + newEntrySize > this.strategy[type].maxSize) {\n      this.evictEntries(type, newEntrySize);\n    }\n  }\n\n  /**\n   * Evict entries based on LRU and priority\n   */\n  private evictEntries(type: keyof CacheStrategy, requiredSpace: number): void {\n    const strategy = this.strategy[type];\n    const entries = this.getEntriesByType(type);\n    \n    // Sort by last access time (LRU)\n    entries.sort((a, b) => a.entry.lastAccess - b.entry.lastAccess);\n\n    let freedSpace = 0;\n    const entriesToEvict: string[] = [];\n\n    for (const { key, entry } of entries) {\n      if (freedSpace >= requiredSpace) break;\n      \n      entriesToEvict.push(key);\n      freedSpace += entry.size;\n    }\n\n    // Evict entries\n    for (const key of entriesToEvict) {\n      this.cache.delete(key);\n      this.stats.evictions++;\n    }\n  }\n\n  /**\n   * Calculate approximate size of data\n   */\n  private calculateSize(data: any): number {\n    try {\n      return new Blob([JSON.stringify(data)]).size;\n    } catch {\n      return 1024; // Default size if calculation fails\n    }\n  }\n\n  /**\n   * Get memory usage estimation\n   */\n  private getMemoryUsage(): number {\n    let totalSize = 0;\n    for (const entry of this.cache.values()) {\n      totalSize += entry.size;\n    }\n    return totalSize;\n  }\n\n  /**\n   * Reset statistics\n   */\n  private resetStats(): void {\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      evictions: 0,\n      totalAccesses: 0\n    };\n  }\n} ","import { UserPreferences } from '../../types/index';\n\nexport interface ValidationLevel {\n  strict: boolean;\n  checkCriticalFields: boolean;\n  checkTimeFormats: boolean;\n  checkLogic: boolean;\n  checkConstraints: boolean;\n}\n\nexport interface ValidationRequest {\n  preferences: UserPreferences;\n  validationLevel: 'strict' | 'relaxed' | 'critical';\n  userId?: string;\n}\n\nexport interface ValidationResponse {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  criticalFields: string[];\n  suggestions: string[];\n  validationLevel: string;\n  timestamp: string;\n}\n\nexport interface ValidationRule {\n  field: keyof UserPreferences;\n  required: boolean;\n  validator: (value: any) => { isValid: boolean; error?: string; warning?: string };\n  critical: boolean;\n}\n\nexport class PreferenceValidationAPI {\n  private static baseURL = '/api/preferences';\n\n  /**\n   * Validate preferences on the server\n   */\n  static async validate(request: ValidationRequest): Promise<ValidationResponse> {\n    try {\n      const response = await fetch(`${this.baseURL}/validate`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(request),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Validation failed: ${response.statusText}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Server validation failed, falling back to client validation:', error);\n      return this.clientSideValidation(request.preferences, request.validationLevel);\n    }\n  }\n\n  /**\n   * Validate critical fields only\n   */\n  static async validateCritical(preferences: UserPreferences): Promise<ValidationResponse> {\n    return this.validate({\n      preferences,\n      validationLevel: 'critical'\n    });\n  }\n\n  /**\n   * Validate with strict rules\n   */\n  static async validateStrict(preferences: UserPreferences): Promise<ValidationResponse> {\n    return this.validate({\n      preferences,\n      validationLevel: 'strict'\n    });\n  }\n\n  /**\n   * Client-side validation fallback\n   */\n  private static clientSideValidation(\n    preferences: UserPreferences, \n    level: string\n  ): ValidationResponse {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const criticalFields: string[] = [];\n    const suggestions: string[] = [];\n\n    const validationRules = this.getValidationRules(level);\n\n    for (const rule of validationRules) {\n      const value = preferences[rule.field];\n      const result = rule.validator(value);\n\n      if (!result.isValid) {\n        if (rule.critical) {\n          errors.push(result.error || `Invalid ${rule.field}`);\n          criticalFields.push(rule.field);\n        } else {\n          warnings.push(result.error || `Invalid ${rule.field}`);\n        }\n      } else if (result.warning) {\n        warnings.push(result.warning);\n      }\n    }\n\n    // Additional logic validation\n    if (level === 'strict' || level === 'relaxed') {\n      const logicValidation = this.validateLogic(preferences);\n      errors.push(...logicValidation.errors);\n      warnings.push(...logicValidation.warnings);\n      suggestions.push(...logicValidation.suggestions);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      criticalFields,\n      suggestions,\n      validationLevel: level,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Get validation rules based on level\n   */\n  private static getValidationRules(level: string): ValidationRule[] {\n    const baseRules: ValidationRule[] = [\n      {\n        field: 'calendar_work_start',\n        required: true,\n        critical: true,\n        validator: (value) => {\n          if (!value) return { isValid: false, error: 'Work start time is required' };\n          if (!this.isValidTimeFormat(value)) {\n            return { isValid: false, error: 'Invalid time format (use HH:MM or HH:MM:SS)' };\n          }\n          return { isValid: true };\n        }\n      },\n      {\n        field: 'calendar_work_end',\n        required: true,\n        critical: true,\n        validator: (value) => {\n          if (!value) return { isValid: false, error: 'Work end time is required' };\n          if (!this.isValidTimeFormat(value)) {\n            return { isValid: false, error: 'Invalid time format (use HH:MM or HH:MM:SS)' };\n          }\n          return { isValid: true };\n        }\n      },\n      {\n        field: 'calendar_working_days',\n        required: true,\n        critical: true,\n        validator: (value) => {\n          if (!Array.isArray(value) || value.length === 0) {\n            return { isValid: false, error: 'Working days must be a non-empty array' };\n          }\n          return { isValid: true };\n        }\n      },\n      {\n        field: 'calendar_min_gap',\n        required: false,\n        critical: false,\n        validator: (value) => {\n          if (value !== undefined && (typeof value !== 'number' || value < 5)) {\n            return { isValid: false, error: 'Minimum gap must be at least 5 minutes' };\n          }\n          return { isValid: true };\n        }\n      }\n    ];\n\n    if (level === 'strict') {\n      baseRules.push(\n        {\n          field: 'preferred_categories',\n          required: false,\n          critical: false,\n          validator: (value) => {\n            if (value && (!Array.isArray(value) || value.length === 0)) {\n              return { isValid: false, error: 'Preferred categories must be a non-empty array' };\n            }\n            return { isValid: true };\n          }\n        }\n      );\n    }\n\n    return baseRules;\n  }\n\n  /**\n   * Validate logical relationships between preferences\n   */\n  private static validateLogic(preferences: UserPreferences): {\n    errors: string[];\n    warnings: string[];\n    suggestions: string[];\n  } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const suggestions: string[] = [];\n\n    // Work hours logic\n    if (preferences.calendar_work_start && preferences.calendar_work_end) {\n      const startMinutes = this.timeToMinutes(preferences.calendar_work_start);\n      const endMinutes = this.timeToMinutes(preferences.calendar_work_end);\n\n      if (startMinutes >= endMinutes) {\n        errors.push('Work start time must be before work end time');\n      }\n\n      if (endMinutes - startMinutes < 60) {\n        warnings.push('Work hours are less than 1 hour');\n        suggestions.push('Consider extending your work hours for better productivity');\n      }\n\n      if (endMinutes - startMinutes > 12 * 60) {\n        warnings.push('Work hours are more than 12 hours');\n        suggestions.push('Consider shorter work hours for better work-life balance');\n      }\n    }\n\n    // Working days logic\n    if (preferences.calendar_working_days) {\n      if (preferences.calendar_working_days.length === 0) {\n        errors.push('At least one working day must be selected');\n      }\n    }\n\n    return { errors, warnings, suggestions };\n  }\n\n  /**\n   * Validate time format (HH:MM or HH:MM:SS)\n   */\n  private static isValidTimeFormat(time: string): boolean {\n    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;\n    return timeRegex.test(time);\n  }\n\n  /**\n   * Convert time string to minutes\n   */\n  private static timeToMinutes(time: string): number {\n    const [hours, minutes] = time.split(':').map(Number);\n    return hours * 60 + (minutes || 0);\n  }\n} ","import { UserPreferences } from '../../types/index';\n\nexport interface PreferenceChangeEvent {\n  field: keyof UserPreferences;\n  oldValue: any;\n  newValue: any;\n  impact: 'low' | 'medium' | 'high';\n  requiresGapRecalculation: boolean;\n  requiresImmediateUpdate: boolean;\n  affectedDates: string[];\n  description: string;\n}\n\nexport interface ChangeDetectionResult {\n  hasChanges: boolean;\n  changes: PreferenceChangeEvent[];\n  requiresGapRecalculation: boolean;\n  requiresImmediateUpdate: boolean;\n  summary: string;\n  affectedDateRange: {\n    start: string;\n    end: string;\n  } | null;\n}\n\nexport interface ImpactConfig {\n  critical: {\n    fields: (keyof UserPreferences)[];\n    impact: 'high';\n    requiresGapRecalculation: boolean;\n    requiresImmediateUpdate: boolean;\n  };\n  medium: {\n    fields: (keyof UserPreferences)[];\n    impact: 'medium';\n    requiresGapRecalculation: boolean;\n    requiresImmediateUpdate: boolean;\n  };\n  low: {\n    fields: (keyof UserPreferences)[];\n    impact: 'low';\n    requiresGapRecalculation: boolean;\n    requiresImmediateUpdate: boolean;\n  };\n}\n\nexport class PreferenceChangeDetector {\n  private static instance: PreferenceChangeDetector;\n  private impactConfig: ImpactConfig;\n\n  private constructor() {\n    this.impactConfig = {\n      critical: {\n        fields: [\n          'calendar_work_start',\n          'calendar_work_end',\n          'calendar_working_days',\n        ],\n        impact: 'high',\n        requiresGapRecalculation: true,\n        requiresImmediateUpdate: true\n      },\n      medium: {\n        fields: [\n          'calendar_min_gap',\n          'calendar_buffer_time',\n          'show_device_calendar_busy',\n          'device_calendar_included_ids',\n        ],\n        impact: 'medium',\n        requiresGapRecalculation: true,\n        requiresImmediateUpdate: false\n      },\n      low: {\n        fields: [\n          'dark_mode',\n          'sound_enabled',\n          'vibration_enabled',\n          'default_energy_level',\n          'preferred_categories',\n          'autostart',\n          'show_timer',\n          'show_device_calendar_titles'\n        ],\n        impact: 'low',\n        requiresGapRecalculation: false,\n        requiresImmediateUpdate: false\n      }\n    };\n  }\n\n  static getInstance(): PreferenceChangeDetector {\n    if (!PreferenceChangeDetector.instance) {\n      PreferenceChangeDetector.instance = new PreferenceChangeDetector();\n    }\n    return PreferenceChangeDetector.instance;\n  }\n\n  /**\n   * Detect changes between old and new preferences\n   */\n  detectChanges(\n    oldPreferences: UserPreferences,\n    newPreferences: UserPreferences\n  ): ChangeDetectionResult {\n    const changes: PreferenceChangeEvent[] = [];\n    let requiresGapRecalculation = false;\n    let requiresImmediateUpdate = false;\n\n    // Check each field for changes\n    for (const field of Object.keys(newPreferences) as (keyof UserPreferences)[]) {\n      const oldValue = oldPreferences[field];\n      const newValue = newPreferences[field];\n\n      if (!this.isEqual(oldValue, newValue)) {\n        const changeEvent = this.createChangeEvent(field, oldValue, newValue);\n        changes.push(changeEvent);\n\n        if (changeEvent.requiresGapRecalculation) {\n          requiresGapRecalculation = true;\n        }\n\n        if (changeEvent.requiresImmediateUpdate) {\n          requiresImmediateUpdate = true;\n        }\n      }\n    }\n\n    const affectedDateRange = this.calculateAffectedDateRange(changes);\n    const summary = this.generateSummary(changes);\n\n    return {\n      hasChanges: changes.length > 0,\n      changes,\n      requiresGapRecalculation,\n      requiresImmediateUpdate,\n      summary,\n      affectedDateRange\n    };\n  }\n\n  /**\n   * Create a change event for a specific field\n   */\n  private createChangeEvent(\n    field: keyof UserPreferences,\n    oldValue: any,\n    newValue: any\n  ): PreferenceChangeEvent {\n    const impact = this.getFieldImpact(field);\n    const config = this.impactConfig[impact];\n\n    return {\n      field,\n      oldValue,\n      newValue,\n      impact: config.impact,\n      requiresGapRecalculation: config.requiresGapRecalculation,\n      requiresImmediateUpdate: config.requiresImmediateUpdate,\n      affectedDates: this.getAffectedDates(field, oldValue, newValue),\n      description: this.generateChangeDescription(field, oldValue, newValue)\n    };\n  }\n\n  /**\n   * Get impact level for a field\n   */\n  private getFieldImpact(field: keyof UserPreferences): 'critical' | 'medium' | 'low' {\n    if (this.impactConfig.critical.fields.includes(field)) {\n      return 'critical';\n    }\n    if (this.impactConfig.medium.fields.includes(field)) {\n      return 'medium';\n    }\n    return 'low';\n  }\n\n  /**\n   * Calculate affected date range for changes\n   */\n  private calculateAffectedDateRange(changes: PreferenceChangeEvent[]): {\n    start: string;\n    end: string;\n  } | null {\n    const criticalChanges = changes.filter(change => \n      change.requiresGapRecalculation && change.impact === 'high'\n    );\n\n    if (criticalChanges.length === 0) {\n      return null;\n    }\n\n    // For critical changes, affect the next 14 days\n    const today = new Date();\n    const start = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;\n    const endDateObj = new Date(today.getTime() + 14 * 24 * 60 * 60 * 1000);\n    const end = `${endDateObj.getFullYear()}-${String(endDateObj.getMonth()+1).padStart(2,'0')}-${String(endDateObj.getDate()).padStart(2,'0')}`;\n\n    return { start, end };\n  }\n\n  /**\n   * Get affected dates for a specific change\n   */\n  private getAffectedDates(\n    field: keyof UserPreferences,\n    _oldValue: any,\n    _newValue: any\n  ): string[] {\n    const dates: string[] = [];\n    const today = new Date();\n\n    // For working days changes, affect all future dates\n    if (field === 'calendar_working_days') {\n      for (let i = 0; i < 14; i++) {\n        const date = new Date(today.getTime() + i * 24 * 60 * 60 * 1000);\n        dates.push(`${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`);\n      }\n    }\n    // For work hours changes, affect all future dates\n    else if (field === 'calendar_work_start' || field === 'calendar_work_end') {\n      for (let i = 0; i < 14; i++) {\n        const date = new Date(today.getTime() + i * 24 * 60 * 60 * 1000);\n        dates.push(`${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`);\n      }\n    }\n    // For other changes, affect today and tomorrow\n    else {\n      dates.push(`${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`);\n      const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);\n      dates.push(`${tomorrow.getFullYear()}-${String(tomorrow.getMonth()+1).padStart(2,'0')}-${String(tomorrow.getDate()).padStart(2,'0')}`);\n    }\n\n    return dates;\n  }\n\n  /**\n   * Generate human-readable change description\n   */\n  private generateChangeDescription(\n    field: keyof UserPreferences,\n    oldValue: any,\n    newValue: any\n  ): string {\n    switch (field) {\n      case 'calendar_work_start':\n        return `Work start time changed from ${oldValue} to ${newValue}`;\n      case 'calendar_work_end':\n        return `Work end time changed from ${oldValue} to ${newValue}`;\n      case 'calendar_working_days': {\n        const oldList = Array.isArray(oldValue) ? oldValue : Object.values(oldValue || {});\n        const newList = Array.isArray(newValue) ? newValue : Object.values(newValue || {});\n        return `Working days changed from ${oldList.join(', ')} to ${newList.join(', ')}`;\n      }\n      case 'calendar_min_gap':\n        return `Minimum gap changed from ${oldValue} to ${newValue} minutes`;\n      case 'dark_mode':\n        return `Dark mode changed from ${oldValue} to ${newValue}`;\n      default:\n        return `${field} changed from ${oldValue} to ${newValue}`;\n    }\n  }\n\n  /**\n   * Generate summary of all changes\n   */\n  private generateSummary(changes: PreferenceChangeEvent[]): string {\n    if (changes.length === 0) {\n      return 'No changes detected';\n    }\n\n    const criticalChanges = changes.filter(c => c.impact === 'high');\n    const mediumChanges = changes.filter(c => c.impact === 'medium');\n    const lowChanges = changes.filter(c => c.impact === 'low');\n\n    const parts: string[] = [];\n\n    if (criticalChanges.length > 0) {\n      parts.push(`${criticalChanges.length} critical change${criticalChanges.length > 1 ? 's' : ''}`);\n    }\n    if (mediumChanges.length > 0) {\n      parts.push(`${mediumChanges.length} medium change${mediumChanges.length > 1 ? 's' : ''}`);\n    }\n    if (lowChanges.length > 0) {\n      parts.push(`${lowChanges.length} minor change${lowChanges.length > 1 ? 's' : ''}`);\n    }\n\n    return parts.join(', ');\n  }\n\n  /**\n   * Deep equality check for values\n   */\n  private isEqual(a: any, b: any): boolean {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (typeof a !== typeof b) return false;\n\n    if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      for (let i = 0; i < a.length; i++) {\n        if (!this.isEqual(a[i], b[i])) return false;\n      }\n      return true;\n    }\n\n    if (typeof a === 'object') {\n      const keysA = Object.keys(a);\n      const keysB = Object.keys(b);\n      if (keysA.length !== keysB.length) return false;\n      for (const key of keysA) {\n        if (!keysB.includes(key)) return false;\n        if (!this.isEqual(a[key], b[key])) return false;\n      }\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Update impact configuration\n   */\n  updateImpactConfig(newConfig: Partial<ImpactConfig>): void {\n    this.impactConfig = { ...this.impactConfig, ...newConfig };\n  }\n\n  /**\n   * Get current impact configuration\n   */\n  getImpactConfig(): ImpactConfig {\n    return { ...this.impactConfig };\n  }\n\n  /**\n   * Check if a field requires gap recalculation\n   */\n  requiresGapRecalculation(field: keyof UserPreferences): boolean {\n    const impact = this.getFieldImpact(field);\n    return this.impactConfig[impact].requiresGapRecalculation;\n  }\n\n  /**\n   * Check if a field requires immediate update\n   */\n  requiresImmediateUpdate(field: keyof UserPreferences): boolean {\n    const impact = this.getFieldImpact(field);\n    return this.impactConfig[impact].requiresImmediateUpdate;\n  }\n} ","import { UserPreferences } from '../../types/index';\nimport { DEFAULT_PREFERENCES } from '../constants';\nimport { PreferencePreloader } from './PreferencePreloader';\nimport { IntelligentCache } from './IntelligentCache';\nimport { PreferenceValidationAPI } from '../api/preferenceValidation';\nimport { PreferenceChangeDetector } from './PreferenceChangeDetector';\n\nexport interface PreferenceValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  criticalFields: string[];\n}\n\nexport interface PreferenceCacheConfig {\n  memoryTTL: number; // 24 hours for preferences\n  validationEnabled: boolean;\n  criticalFields: string[];\n  defaultFallback: boolean;\n  enablePreloading: boolean;\n  enableIntelligentCache: boolean;\n  enableChangeDetection: boolean;\n  enableServerValidation: boolean;\n}\n\nexport class PreferenceManager {\n  private static instance: PreferenceManager;\n  private preferences: UserPreferences | null = null;\n  private isLoading = false;\n  private lastLoadTime = 0;\n  private config: PreferenceCacheConfig;\n  private storage: any;\n  private preloader?: PreferencePreloader;\n  private intelligentCache?: IntelligentCache;\n  private changeDetector?: PreferenceChangeDetector;\n\n  private constructor(storage: any, config: Partial<PreferenceCacheConfig> = {}) {\n    this.storage = storage;\n    this.config = {\n      memoryTTL: 24 * 60 * 60 * 1000, // 24 hours\n      validationEnabled: true,\n      criticalFields: [\n        'calendar_work_start',\n        'calendar_work_end', \n        'calendar_working_days',\n        'calendar_min_gap'\n      ],\n      defaultFallback: true,\n      enablePreloading: true,\n      enableIntelligentCache: true,\n      enableChangeDetection: true,\n      enableServerValidation: true,\n      ...config\n    };\n\n    // Initialize Phase 2 components (but not preloader to avoid circular dependency)\n    if (this.config.enableIntelligentCache) {\n      this.intelligentCache = new IntelligentCache();\n    }\n\n    if (this.config.enableChangeDetection) {\n      this.changeDetector = PreferenceChangeDetector.getInstance();\n    }\n  }\n\n  static getInstance(storage: any, config?: Partial<PreferenceCacheConfig>): PreferenceManager {\n    if (!PreferenceManager.instance) {\n      PreferenceManager.instance = new PreferenceManager(storage, config);\n      // Initialize preloader after instance creation to avoid circular dependency\n      if (PreferenceManager.instance.config.enablePreloading) {\n        PreferenceManager.instance.preloader = PreferencePreloader.getInstance();\n        PreferenceManager.instance.preloader.initialize(storage);\n      }\n      return PreferenceManager.instance;\n    }\n\n    // If instance already exists, refresh its dependencies when a new storage is provided\n    if (storage && PreferenceManager.instance.storage !== storage) {\n      PreferenceManager.instance.storage = storage;\n      if (PreferenceManager.instance.preloader) {\n        PreferenceManager.instance.preloader.initialize(storage);\n      }\n    }\n\n    // Optionally merge in any new config flags without removing existing ones\n    if (config && Object.keys(config).length > 0) {\n      PreferenceManager.instance.config = {\n        ...PreferenceManager.instance.config,\n        ...config,\n      };\n    }\n\n    return PreferenceManager.instance;\n  }\n\n  /**\n   * Get preferences with optimized loading strategy\n   * Priority: Intelligent Cache -> Memory cache -> Storage -> Server -> Defaults\n   */\n  async getPreferences(): Promise<UserPreferences> {\n    const now = Date.now();\n    \n    // Check intelligent cache first (Phase 2)\n    if (this.intelligentCache) {\n      const cachedPrefs = this.intelligentCache.getFullPreferences();\n      if (cachedPrefs) {\n        console.log('⚡ Preferences retrieved from intelligent cache');\n        return cachedPrefs;\n      }\n    }\n    \n    // Check if we have valid cached preferences\n    if (this.preferences && (now - this.lastLoadTime) < this.config.memoryTTL) {\n      console.log('⚡ Preferences retrieved from memory cache');\n      return this.preferences;\n    }\n\n    // Prevent concurrent loading\n    if (this.isLoading) {\n      console.log('⏳ Preferences already loading, waiting...');\n      while (this.isLoading) {\n        await new Promise(resolve => setTimeout(resolve, 10));\n      }\n      return this.preferences || DEFAULT_PREFERENCES;\n    }\n\n    this.isLoading = true;\n    \n    try {\n      console.log('🔄 Loading preferences...');\n      \n      // Try storage first (fastest)\n      let prefs = await this.loadFromStorage();\n      \n      if (!prefs) {\n        // Try server if storage is empty\n        prefs = await this.loadFromServer();\n      }\n      \n      if (!prefs && this.config.defaultFallback) {\n        // Use defaults as last resort\n        prefs = DEFAULT_PREFERENCES;\n        console.log('⚠️ Using default preferences');\n      }\n\n      if (prefs) {\n        // Server-side validation (Phase 2)\n        if (this.config.enableServerValidation) {\n          try {\n            const validation = await PreferenceValidationAPI.validateStrict(prefs);\n            if (!validation.isValid) {\n              console.warn('⚠️ Server validation failed:', validation.errors);\n              if (this.config.defaultFallback) {\n                prefs = this.mergeWithDefaults(prefs);\n              }\n            }\n          } catch (validationError) {\n            console.warn('⚠️ Server validation failed, using client validation:', validationError);\n            // Fall back to client validation\n            const validation = this.validatePreferences(prefs);\n            if (!validation.isValid) {\n              console.warn('⚠️ Client validation failed:', validation.errors);\n              if (this.config.defaultFallback) {\n                prefs = this.mergeWithDefaults(prefs);\n              }\n            }\n          }\n        } else {\n          // Client-side validation\n          const validation = this.validatePreferences(prefs);\n          if (!validation.isValid) {\n            console.warn('⚠️ Preference validation failed:', validation.errors);\n            if (this.config.defaultFallback) {\n              prefs = this.mergeWithDefaults(prefs);\n            }\n          }\n        }\n\n        this.preferences = prefs;\n        this.lastLoadTime = now;\n        \n        // Cache in intelligent cache (Phase 2)\n        if (this.intelligentCache) {\n          this.intelligentCache.setFullPreferences(prefs);\n        }\n        \n        // Cache in storage for next time\n        await this.saveToStorage(prefs);\n        \n        console.log('✅ Preferences loaded successfully');\n        return prefs;\n      }\n\n      throw new Error('Failed to load preferences from all sources');\n    } catch (error) {\n      console.error('❌ Error loading preferences:', error);\n      if (this.config.defaultFallback) {\n        return DEFAULT_PREFERENCES;\n      }\n      throw error;\n    } finally {\n      this.isLoading = false;\n    }\n  }\n\n  /**\n   * Save preferences with validation and caching\n   */\n  async savePreferences(preferences: UserPreferences): Promise<void> {\n    console.log('💾 Saving preferences...');\n    \n    // Change detection (Phase 2)\n    if (this.changeDetector && this.preferences) {\n      const normalizeDays = (val: any) => Array.isArray(val) ? val : (val && typeof val === 'object' ? Object.values(val) : val);\n      const normalizedOld = { ...this.preferences, calendar_working_days: normalizeDays(this.preferences.calendar_working_days) } as UserPreferences;\n      const normalizedNew = { ...preferences, calendar_working_days: normalizeDays(preferences.calendar_working_days) } as UserPreferences;\n      const changeResult = this.changeDetector.detectChanges(normalizedOld, normalizedNew);\n      if (changeResult.hasChanges) {\n        console.log('🔄 Preference changes detected:', changeResult.summary);\n        \n        if (changeResult.requiresGapRecalculation) {\n          console.log('⚠️ Gap recalculation required for affected dates:', changeResult.affectedDateRange);\n          // Emit change event for gap recalculation\n          this.emitPreferenceChangeEvent(changeResult);\n        }\n      }\n    }\n    \n            // Server-side validation (Phase 2) - Temporarily disabled for debugging\n        if (false && this.config.enableServerValidation) {\n          try {\n            const validation = await PreferenceValidationAPI.validateStrict(preferences);\n            if (!validation.isValid) {\n              throw new Error(`Server validation failed: ${validation.errors.join(', ')}`);\n            }\n          } catch (validationError) {\n            console.warn('⚠️ Server validation failed, using client validation:', validationError);\n            // Fall back to client validation\n            if (this.config.validationEnabled) {\n              const validation = this.validatePreferences(preferences);\n              if (!validation.isValid) {\n                throw new Error(`Invalid preferences: ${validation.errors.join(', ')}`);\n              }\n            }\n          }\n        } else {\n          // Client-side validation - Temporarily disabled for debugging\n          if (false && this.config.validationEnabled) {\n            const validation = this.validatePreferences(preferences);\n            if (!validation.isValid) {\n              console.warn('⚠️ Client validation failed, but allowing save for debugging:', validation.errors);\n              // Temporarily allow invalid preferences for debugging\n              // throw new Error(`Invalid preferences: ${validation.errors.join(', ')}`);\n            }\n          }\n        }\n\n    // Update intelligent cache (Phase 2)\n    if (this.intelligentCache) {\n      this.intelligentCache.setFullPreferences(preferences);\n    }\n\n    // Update memory cache immediately\n    this.preferences = preferences;\n    this.lastLoadTime = Date.now();\n\n    // Save to storage\n    await this.saveToStorage(preferences);\n    \n    // Sync to server in background\n    this.syncToServer(preferences).catch(error => {\n      console.warn('⚠️ Background server sync failed:', error);\n    });\n\n    console.log('✅ Preferences saved successfully');\n  }\n\n  /**\n   * Get critical preferences only (for immediate use)\n   */\n  getCriticalPreferences(): Partial<UserPreferences> {\n    // Check intelligent cache first (Phase 2)\n    if (this.intelligentCache) {\n      const cachedCritical = this.intelligentCache.getCriticalPreferences();\n      if (cachedCritical) {\n        return cachedCritical;\n      }\n    }\n\n    if (!this.preferences) {\n      const defaultCritical = {\n        calendar_work_start: DEFAULT_PREFERENCES.calendar_work_start,\n        calendar_work_end: DEFAULT_PREFERENCES.calendar_work_end,\n        calendar_working_days: DEFAULT_PREFERENCES.calendar_working_days,\n        calendar_min_gap: DEFAULT_PREFERENCES.calendar_min_gap\n      };\n\n      // Cache default critical preferences\n      if (this.intelligentCache) {\n        this.intelligentCache.setCriticalPreferences(defaultCritical);\n      }\n\n      return defaultCritical;\n    }\n\n          const criticalPrefs = this.config.criticalFields.reduce((acc, field) => {\n        const value = this.preferences![field as keyof UserPreferences];\n        if (value !== undefined) {\n          (acc as any)[field] = value;\n        }\n        return acc;\n      }, {} as Partial<UserPreferences>);\n\n    // Cache critical preferences\n    if (this.intelligentCache) {\n      this.intelligentCache.setCriticalPreferences(criticalPrefs);\n    }\n\n    return criticalPrefs;\n  }\n\n  /**\n   * Check if preferences are loaded and valid\n   */\n  isLoaded(): boolean {\n    return this.preferences !== null && (Date.now() - this.lastLoadTime) < this.config.memoryTTL;\n  }\n\n  /**\n   * Force refresh preferences from server\n   */\n  async refresh(): Promise<UserPreferences> {\n    console.log('🔄 Force refreshing preferences...');\n    this.preferences = null;\n    this.lastLoadTime = 0;\n    return this.getPreferences();\n  }\n\n  /**\n   * Clear memory cache\n   */\n  clearCache(): void {\n    this.preferences = null;\n    this.lastLoadTime = 0;\n    \n    // Clear intelligent cache (Phase 2)\n    if (this.intelligentCache) {\n      this.intelligentCache.clear();\n    }\n    \n    console.log('🗑️ Preference cache cleared');\n  }\n\n  /**\n   * Preload critical preferences (Phase 2)\n   */\n  async preloadCritical(): Promise<void> {\n    if (this.preloader) {\n      await this.preloader.preloadCritical();\n    }\n  }\n\n  /**\n   * Preload full preferences (Phase 2)\n   */\n  async preloadFull(): Promise<void> {\n    if (this.preloader) {\n      await this.preloader.preloadFull();\n    }\n  }\n\n  /**\n   * Get cache statistics (Phase 2)\n   */\n  getCacheStats(): any {\n    if (this.intelligentCache) {\n      return this.intelligentCache.getStats();\n    }\n    return null;\n  }\n\n  /**\n   * Get preload status (Phase 2)\n   */\n  getPreloadStatus(): any {\n    if (this.preloader) {\n      return this.preloader.getStatus();\n    }\n    return null;\n  }\n\n  /**\n   * Emit preference change event for gap recalculation\n   */\n  private emitPreferenceChangeEvent(changeResult: any): void {\n    // This would integrate with your existing gap recalculation system\n    // For now, we'll just log the event\n    console.log('📡 Preference change event emitted:', {\n      requiresGapRecalculation: changeResult.requiresGapRecalculation,\n      affectedDateRange: changeResult.affectedDateRange,\n      changes: changeResult.changes\n    });\n    \n    // You can integrate this with your existing gap recalculation logic\n    // For example, dispatch a custom event or call a callback\n    if (typeof window !== 'undefined') {\n      window.dispatchEvent(new CustomEvent('preferenceChange', {\n        detail: changeResult\n      }));\n    }\n  }\n\n  /**\n   * Validate preferences structure and critical fields\n   */\n  private validatePreferences(preferences: UserPreferences): PreferenceValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const criticalFields: string[] = [];\n\n    // Check critical fields\n    for (const field of this.config.criticalFields) {\n      const value = preferences[field as keyof UserPreferences];\n      if (value === undefined || value === null || value === '') {\n        errors.push(`Missing critical field: ${field}`);\n        criticalFields.push(field);\n      }\n    }\n\n    // Validate work hours\n    if (preferences.calendar_work_start && preferences.calendar_work_end) {\n      const start = this.timeToMinutes(preferences.calendar_work_start);\n      const end = this.timeToMinutes(preferences.calendar_work_end);\n      \n      if (start >= end) {\n        errors.push('Work start time must be before work end time');\n      }\n      \n      if (end - start < 60) {\n        warnings.push('Work hours are less than 1 hour');\n      }\n    }\n\n    // Validate working days\n    if (preferences.calendar_working_days) {\n      if (!Array.isArray(preferences.calendar_working_days) || preferences.calendar_working_days.length === 0) {\n        errors.push('Working days must be a non-empty array');\n      }\n    }\n\n    // Validate time format\n    const timeFields = ['calendar_work_start', 'calendar_work_end'];\n    for (const field of timeFields) {\n      const value = preferences[field as keyof UserPreferences];\n      if (value && typeof value === 'string' && !this.isValidTimeFormat(value)) {\n        warnings.push(`Invalid time format for ${field}: ${value}`);\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      criticalFields\n    };\n  }\n\n  /**\n   * Merge preferences with defaults for missing critical fields\n   */\n  private mergeWithDefaults(preferences: UserPreferences): UserPreferences {\n    return {\n      ...DEFAULT_PREFERENCES,\n      ...preferences,\n      // Ensure critical fields are present\n      calendar_work_start: preferences.calendar_work_start || DEFAULT_PREFERENCES.calendar_work_start,\n      calendar_work_end: preferences.calendar_work_end || DEFAULT_PREFERENCES.calendar_work_end,\n      calendar_working_days: preferences.calendar_working_days || DEFAULT_PREFERENCES.calendar_working_days,\n      calendar_min_gap: preferences.calendar_min_gap || DEFAULT_PREFERENCES.calendar_min_gap\n    };\n  }\n\n  /**\n   * Load preferences from local storage\n   */\n  private async loadFromStorage(): Promise<UserPreferences | null> {\n    try {\n      return await this.storage.getPreferences();\n    } catch (error) {\n      console.warn('⚠️ Failed to load preferences from storage:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Load preferences from server\n   */\n  private async loadFromServer(): Promise<UserPreferences | null> {\n    try {\n      const { preferencesAPI } = await import('../api');\n      return await preferencesAPI.get();\n    } catch (error) {\n      console.warn('⚠️ Failed to load preferences from server:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Save preferences to local storage\n   */\n  private async saveToStorage(preferences: UserPreferences): Promise<void> {\n    try {\n      await this.storage.savePreferences(preferences);\n    } catch (error) {\n      console.error('❌ Failed to save preferences to storage:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Sync preferences to server in background\n   */\n  private async syncToServer(preferences: UserPreferences): Promise<void> {\n    try {\n      const { preferencesAPI } = await import('../api');\n      const diff = this.preferences ? this.computePreferenceDiff(this.preferences, preferences) : preferences;\n      if (Object.keys(diff).length === 0) return;\n      await preferencesAPI.patch(diff);\n    } catch (error) {\n      console.warn('⚠️ Background server sync failed:', error);\n    }\n  }\n\n  private computePreferenceDiff(oldPrefs: any, newPrefs: any) {\n    const normalizeDays = (val: any) => Array.isArray(val) ? val : (val && typeof val === 'object' ? Object.values(val) : []);\n    const diff: any = {};\n    const keys = Object.keys(newPrefs || {});\n    for (const k of keys) {\n      const ov = k === 'calendar_working_days' ? normalizeDays(oldPrefs?.[k]) : oldPrefs?.[k];\n      const nv = k === 'calendar_working_days' ? normalizeDays(newPrefs?.[k]) : newPrefs?.[k];\n      if (JSON.stringify(ov) !== JSON.stringify(nv)) diff[k] = nv;\n    }\n    return diff;\n  }\n\n  /**\n   * Convert time string to minutes for validation\n   */\n  private timeToMinutes(time: string): number {\n    const [hours, minutes] = time.split(':').map(Number);\n    return hours * 60 + (minutes || 0);\n  }\n\n  /**\n   * Validate time format (HH:MM or HH:MM:SS)\n   */\n  private isValidTimeFormat(time: string): boolean {\n    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;\n    return timeRegex.test(time);\n  }\n} "],"file":"assets/PreferenceManager-C-qDvyTZ.js"}